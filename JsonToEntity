'use strict';
(function(window, undefined) {


if (typeof Object.create !== 'function') {
    Object.create = function (o) {
        var F = function () {};
        F.prototype = o;
        return new F();
    };
}

/**
 * Tomando una respuesta acorde a JSON:API https://jsonapi.org/ permite transformarla a un objeto
 * similar a la entidad solicitada así como transformar en string sus relaciones si se encuentran
 * en el array included response[data[], included[]}]
 * @constructor
 * @param {Array} data - Conjunto de entidades obtenidas en la consulta.
 * @param {Array|null} included - Entidades referenciadas en relationships para cada elemento del array de data
 * @example
 * data: [
 *   {
 *      type: "mapsurveyor", 
 *      id: "ESFE80E1GPT000001.1",
 *      attributes:{
 *          surveyorid:ESFE80E1GPT000001...
 *      },
 *       links[]
 *       relationships[{type: person, id:ESFE80E1GPT000001}]
 *       …},
 *       …]
 * included: [{type: "person", id: "ESFE80E1GPT000001",…}]
 * JsonSerializer(data, included)
 */
function CaveJsonResponseManager(data, included) {
    this.data = data;
    this.included = included||null;
    this.ret= [];
}

/**
 * Dado un objeto JSON raiz, trata de encontrar la entidad a la que corresponde mediante
 * el valor de "type" capitalizado.
 * Las entidades se registran en este fichero... por ahora
 * @param {Object} data - The document’s “primary data” (JSON:API)
 */
CaveJsonResponseManager.prototype.getEntity= function(data){
    let entity= data.type.charAt(0).toUpperCase() + data.type.slice(1);

    switch (entity){
        case 'Person': return new Person(data);
        default: return null
    }
}

/**
 * Busca en el array included las relaciones referenciadas en JSON.relationships
 * @param {Object} data -   relationship[data{id, type},...]
 * @return {Object|null} Retorna la instancia que representa ese objeto o null
 */
CaveJsonResponseManager.prototype.getIncluded= function(data){
    let inc, ret, attr, proto;
    //loop included
    for (let key in this.included) 
    {
        inc= this.included[key]
        //Si hay match entre {type, id} trata de devolver la entidad
        if (inc.type===data.type && inc.id===data.id) {
            return this.getEntity(inc)
        }
    }
    return null
}

/**
 * Retorna un array de objetos que se acerque a la descripción de la entidad
 * 
 * @param {Array} fields - Campos a devolver
 * @return {Object|null}
 */
CaveJsonResponseManager.prototype.toJsonArray = function(fields= []) {
    let i, meta, attr, inc, el, ret= {};
    //loop response.data
    for(i=0; i<this.data.length;i++)
    {
        //top JSON:API resource
        el= this.data[i];
        //Creamos el objeto a devolver.
        //Añadimos la clave meta donde ponemos aquello que no es de la entidad pero puede ser de utilidad
        ret= {
            meta: {
                type: el.type,
                links: el.hasOwnProperty('links')? el.links : {},
                relationships:  el.hasOwnProperty('relationships')? el.relationships : {}
                },
            id: el.id,
        }
        //loop sobre attributes {JSON}
        attr = this.data[i]['attributes']
        for (let key in attr) {
            //Si la clave se encuentra en relationships buscamos en this.included
                if(ret.meta.relationships.hasOwnProperty(key)){
                    //Buscamos mediante {id, type} y tratamos de instanciar para pasarlo a string/link (TODO mejorar?)
                    //ya que el valor de esta clave es un ID. Si no se encuentra, dejamos el ID como valor
                    inc= this.getIncluded(ret.meta.relationships[key].data)
                    //TODO función en meta para devolver el objeto creado mediante getIncluded()
                    ret[key] = inc ? inc.toLink() : attr[key];
                }else{
                    //Si no hay relaciones el valor se queda como tal
                    ret[key]= attr[key];
                }
        }
            //Añadimos el objeto creado como retorno
            this.ret[i]= ret;
    }
    return this.ret
};

/**
 * No me gusta el nombre de esta función ....
 * Retorna un array de objetos JSON de acuerdo a las claves solicitadas
 * @param {Array} fields - Claves del objeto a devolver
 * @param {Array} fn - array de pares {key, function(element)} que se ejecuta al encontrar esa clave y retorna un valor calculado.
 *                      key debe encontrarse entre los elementos del array field
 * @return {Array}
 */
    CaveJsonResponseManager.prototype.get = function(fields= [], fn=null) {

        let r, ret=[], i, el, 
            parsed= this.ret.length? this.ret : this.toJsonArray();
        // console.log(parsed)

        for(i=0; i<parsed.length; i++){
            r={}
            el= parsed[i]
            for(let key in el){
                if(fields.indexOf(key)!==-1){
                    if(fn && fn.hasOwnProperty(key)){
                        r[key]= fn[key](el)
                    }else{
                        r[key]=el[key]
                    }

                }

            }
            ret.push(r);
        }
        return ret;
    }




/**
 * Para representar los resultados en una tabla, obtenemos el objeto json y lo
 * convertimos en array respetando el orden dado en fields eliminando las claves.
 * Parece una tontería, pero economiza código.
 */ 
    CaveJsonResponseManager.prototype.toArray = function(fields= [], fn=null) {
        let ret=[], i,r, d= this.get(fields, fn)
        //es array
        for(i=0; i<d.length; i++){
            r=[]
            //es json
            for(let key in d[i]){
                //order by fields array
                r[fields.indexOf(key)]=d[i][key]
                // r.push(d[i][key])
            }
            ret.push(r)
        }
        return ret;
    }

/**
 *  JSON:API resource
 *
 * @constructor
 * @see https://jsonapi.org/
 * @param {Object} data Recurso JSON:API obtenido en el array response
 */
function jsonApiSpec(data){
    this.id = data.id;
    this.type= data.type;
    this.attributes = data.attributes;
    this.links = data.links||null;
    this.relationships= data.relationships||null;
    this.selfLink= function(){
        return (this.links && this.links.hasOwnProperty('self')) ? this.links.self : null;
        }
    
}

function checkEntityType(type, expected){
        if(this.type!==expected throw new ExcepcionInvalidType(this.type, expected);

}

function ExcepcionInvalidType(type, expected) {
   this.type = valor;
   this.expected= expected;
   this.mensaje = "El tipo de entidad no se corresponde con el especificado";
   this.toString = function() {
       return ['Invalid type "', this.type, '" expected "', this.expected, '"'].join('');
   };
}



/**
 * Person class. Representación javascript de la entidad Person
 *
 * @constructor
 * @param {Object} data Recurso JSON:API obtenido en el array response
 */
function Person(data) {
    jsonApiSpec.call(this, data);
    checkEntityType(this.type, 'person')
}


Person.prototype.toString = function () {
    return [ this.attributes.name, " ", this.attributes.surname].join("");
};

Person.prototype.toLink = function () {
    if(this.data.hasOwnProperty('links') && this.data.links.hasOwnProperty('self')){
        return ['<a href="',this.data.links.self,'">', this.attributes.name, ' ', this.attributes.surname, '</a>'].join('');
    }else{
        return this.toString()
    }
};

Person.prototype.toJson = function () {
    let ret= {
        id: this.id,
        link: this.toLink()
    };
    for (let key in this.attributes) {
        ret[key]= this.attributes[key]
    }
    return ret;
};

Person.prototype = Object.create(jsonApiSpec.prototype);


    window.CaveJsonResponseManager= CaveJsonResponseManager;
}(window));
